### MySQL 从表中检索信息(查询)

#### 1. 选择特定列

​	如果您不想查看表中的整行，只需将您感兴趣的列命名为逗号分隔。 例如，如果您想知道您的动物何时出生，请选择名称和出生列：

**`SELECT col_name FROM tb_name`**

```
mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+-----------+
```

找出谁拥有宠物，使用此查询：

```
mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
```

​	请注意，查询只是从每条记录中检索所有者列，其中一些列出现不止一次。 要最小化输出，请通过添加关键字DISTINCT检索每个唯一的输出记录一次：

**`SELECT DISTINCT col_name FROM tb_name`**	 **去重**

```\
mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
```

​	您可以使用WHERE子句将行选择与列选择组合在一起。 例如，要仅获取狗和猫的出生日期，请使用以下查询：

```
mysql> SELECT name, species, birth FROM pet
       WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
```

#### 2.  排序行

​	您可能已在前面的示例中注意到结果行没有按特定顺序显示。 当行以某种有意义的方式排序时，通常更容易检查查询输出。 要对结果进行排序，请使用 **`ORDER BY`** 子句。

这是动物的生日，按日期排序：

**`SELECT col_name FROM tb_name ORDER BY col_name`**

```
mysql> SELECT name, birth FROM pet ORDEY BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
```

​	在字符类型列上，排序与所有其他比较操作一样，通常以不区分大小写的方式执行。 这意味着除了它们的情况之外，对于相同的列，订单是未定义的。 您可以使用**BINARY**强制对列进行区分大小写的排序，如下所示：**ORDER BY BINARY col_name**。

​	默认排序顺序是升序，首先是最小值。 要按反向（降序）排序，请将**DESC**关键字添加到要排序的列的名称：

**`SELECT col_name FROM tb_name ORDEY BY col_name DESC`** 降序排序

```
myql> SELECT name, birth FROM pet ORDER BY birth DESC;
```

​	您可以对多个列进行排序，并且可以按不同方向对不同列进行排序。 例如，按动物类型按升序排序，然后按动物类型中的出生日期降序排列（最年轻的动物首先），使用以下查询

```
mysql> SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
```

DESC关键字仅适用于紧接其之前的列名（出生）; 它不会影响物种列的排序顺序。

#### 3. 日期计算

MySQL提供了几个可用于在日期上执行计算的函数，例如，计算年龄或提取日期的部分。

要确定每只宠物的年龄，请使用 **TIMESTAMPDIFF（）**函数。 它的参数是你想要表达结果的单位，以及两个可以取得差异的日期。 以下查询显示了每只宠物的出生日期，当前日期和年龄。 别名（age）用于使最终输出列标签更有意义。

```
mysql> SELECT name, birth, CURDATE(), 
		TIMESTAMPDIFF(YEAR, birth CURDATE()) AS age FROM pet
+----------+------------+------------+------+
| name     | birth      | now_data   | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2019-08-29 |   26 |
| Claws    | 1994-03-17 | 2019-08-29 |   25 |
| Buffy    | 1989-05-13 | 2019-08-29 |   30 |
| Fang     | 1990-08-27 | 2019-08-29 |   29 |
| Bowser   | 1979-08-31 | 2019-08-29 |   39 |
| Chirpy   | 1998-09-11 | 2019-08-29 |   20 |
| Whistler | 1997-12-09 | 2019-08-29 |   21 |
| Slim     | 1996-04-29 | 2019-08-29 |   23 |
+----------+------------+------------+------+

```

```
SELECT col_name CURDATE() TIMESTAMPDIFF(unit, begin,end) FROM tb_name
```

>  **Unit 参数支持单位** : MICROSECOND、SECOND、MINUTE、HOUR、WEEK、MONTH、QUARTER、YEAR。 时间单位  

>  **begin** : 开始时间

>  **end** : 结束时间

>  **CURDATE()函数** ：获取当前日期

查询有效，但如果以某种顺序显示行，则可以更轻松地获取结果。 这可以通过添加ORDER BY name子句来按名称对输出进行排序来完成：

```
mysql> SELECT name, birth, CURDATE(),
		TIMESTAMPDIFF(YEAR, birth, CURDTE()) AS age 
		FROM pet ORDER BY name;
+----------+------------+------------+------+
| name     | birth      | now_data   | age  |
+----------+------------+------------+------+
| Bowser   | 1979-08-31 | 2019-08-29 |   39 |
| Buffy    | 1989-05-13 | 2019-08-29 |   30 |
| Chirpy   | 1998-09-11 | 2019-08-29 |   20 |
| Claws    | 1994-03-17 | 2019-08-29 |   25 |
| Fang     | 1990-08-27 | 2019-08-29 |   29 |
| Fluffy   | 1993-02-04 | 2019-08-29 |   26 |
| Slim     | 1996-04-29 | 2019-08-29 |   23 |
| Whistler | 1997-12-09 | 2019-08-29 |   21 |
+----------+------------+------------+------+

```

要按年龄而不是名称对输出进行排序，只需使用不同的ORDER BY子句：

```
mysql> SELECT name, birth, CURDATE(),
		TIMESTAMPDIFF(YEAR, birth, CURDATE()) AS age
		FROM pet ORDER BY age;
+----------+------------+------------+------+
| name     | birth      | now_date   | age  |
+----------+------------+------------+------+
| Chirpy   | 1998-09-11 | 2019-08-29 |   20 |
| Whistler | 1997-12-09 | 2019-08-29 |   21 |
| Slim     | 1996-04-29 | 2019-08-29 |   23 |
| Claws    | 1994-03-17 | 2019-08-29 |   25 |
| Fluffy   | 1993-02-04 | 2019-08-29 |   26 |
| Fang     | 1990-08-27 | 2019-08-29 |   29 |
| Buffy    | 1989-05-13 | 2019-08-29 |   30 |
| Bowser   | 1979-08-31 | 2019-08-29 |   39 |
+----------+------------+------------+------+

```

​	类似的查询可用于确定死亡动物的死亡年龄。 您可以通过检查死亡值是否为NULL来确定这些动物。 然后，对于那些具有非NULL值的人，计算死亡和出生值之间的差异：

```
mysql> SELECT name, birth, death, 
		TIMESTAMPDIFF(YEAR, birth, death) AS age
        FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1979-08-31 | 1995-07-29 |   15 |
+--------+------------+------------+------+


```

​	如果你想知道哪些动物下个月有生日怎么办？ 对于这种类型的计算，年和日是无关紧要的; 你只想提取出生列的月份部分。 MySQL提供了几个用于提取日期部分的函数，例如**YEAR（） ** ，**MONTH（）** 和 **DAYOFMONTH（）** 。 **MONTH（）** 是适当的功能。 要查看它是如何工作的，运行一个简单的查询，显示出生和MONTH（出生）的值：

```
mysql> SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
```

如果当前月份是12月，则会出现一个小的复杂情况。 您不能仅仅在月份数字（12）中添加一个并查找在第13个月出生的动物，因为没有这样的月份。 相反，你寻找1月（第1个月）出生的动物。

您可以编写查询，以便无论当前月份是什么，它都可以工作，因此您不必使用特定月份的数字。**DATE_ADD（）** 使您可以将时间间隔添加到给定日期。 如果您将一个月添加到**CURDATE（）**的值，然后使用**MONTH（）**提取月份部分，结果将生成查找生日的月份：

```
mysql> SELECT name, birth FROM pet
		WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(), INTERVAL 1 MONTH));
+--------+------------+
| name   | birth      |
+--------+------------+
| Chirpy | 1998-09-11 |
+--------+------------+

```

​	完成相同任务的另一种方法是在使用模数函数（MOD）将月值设置为0（如果它当前为12）后，添加1以获取当前一个之后的下一个月：

```
mysql> SELECT name, birth FROM pet
        WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1
+--------+------------+
| name   | birth      |
+--------+------------+
| Chirpy | 1998-09-11 |
+--------+------------+

```

MONTH（）返回1到12之间的数字.MOD（12）返回0到11之间的数字。所以加法必须在MOD（）之后，否则我们将从11月（11）到1月（1）。

如果计算使用无效日期，则计算失败并生成警告：

```
mysql> SELECT '2018-10-31' + INTERVAL 1 DAY;
+-------------------------------+
| '2018-10-31' + INTERVAL 1 DAY |
+-------------------------------+
| 2018-11-01                    |
+-------------------------------+
mysql> SELECT '2018-10-32' + INTERVAL 1 DAY;
+-------------------------------+
| '2018-10-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+
mysql> SHOW WARNINGS;
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2018-10-32' |
+---------+------+----------------------------------------+
```

> 定义：INTERVAL(N,N1,N2,N3,..........)
>
> INTERVAL()函数进行比较列表(N1，N2，N3等等)中的N值。该函数如果N<N1返回0，如果N<N2返回1，如果N<N3返回2 等等。如果N为NULL，它将返回-1。列表值必须是N1<N2<N3的形式才能正常工作。下面的代码是显示 INTERVAL()函数如何工作的一个简单的例子

```
mysql>SELECT INTERVAL(6,1,2,3,4,5,6,7,8,9,10);
+---------------------------------------------------------+
| INTERVAL(6,1,2,3,4,5,6,7,8,9,10)                        |
+---------------------------------------------------------+
| 6                                                       |
+---------------------------------------------------------+
1 row in set (0.00 sec)

```

> 请记住，6是从零开始的索引，列表第一个值的值大于N. 在我们的例子中，7是错误的值，它是位于第六索引插槽。